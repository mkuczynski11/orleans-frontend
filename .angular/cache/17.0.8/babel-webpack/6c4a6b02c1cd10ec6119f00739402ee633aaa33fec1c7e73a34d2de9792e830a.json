{"ast":null,"code":"import { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../_services/token-storage.service\";\nimport * as i2 from \"../_services/auth.service\";\nconst TOKEN_HEADER_KEY = 'Authorization';\n// export class AuthInterceptor implements HttpInterceptor {\nexport class AuthInterceptor {\n  constructor(tokenService, authService) {\n    this.tokenService = tokenService;\n    this.authService = authService;\n    this.isRefreshing = false;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n  }\n  //   intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<Object>> {\n  //     let authReq = req;\n  //     const token = this.tokenService.getToken();\n  //     if (token != null) {\n  //       authReq = this.addTokenHeader(req, token);\n  //     }\n  //     return next.handle(authReq).pipe(catchError(error => {\n  //       if (error instanceof HttpErrorResponse && !authReq.url.includes('auth/signin') && error.status === 401) {\n  //         return this.handle401Error(authReq, next);\n  //       }\n  //       return throwError(error);\n  //     }));\n  //   }\n  //   private handle401Error(request: HttpRequest<any>, next: HttpHandler) {\n  //     if (!this.isRefreshing) {\n  //       this.isRefreshing = true;\n  //       this.refreshTokenSubject.next(null);\n  //       const token = this.tokenService.getRefreshToken();\n  //       if (token)\n  //         return this.authService.refreshToken(token).pipe(\n  //           switchMap((token: any) => {\n  //             this.isRefreshing = false;\n  //             this.tokenService.saveToken(token.accessToken);\n  //             this.refreshTokenSubject.next(token.accessToken);\n  //             return next.handle(this.addTokenHeader(request, token.accessToken));\n  //           }),\n  //           catchError((err) => {\n  //             this.isRefreshing = false;\n  //             this.tokenService.signOut();\n  //             return throwError(err);\n  //           })\n  //         );\n  //     }\n  //     return this.refreshTokenSubject.pipe(\n  //       filter(token => token !== null),\n  //       take(1),\n  //       switchMap((token) => next.handle(this.addTokenHeader(request, token)))\n  //     );\n  //   }\n  addTokenHeader(request, token) {\n    return request.clone({\n      headers: request.headers.set(TOKEN_HEADER_KEY, 'Bearer ' + token)\n    });\n  }\n  static #_ = this.ɵfac = function AuthInterceptor_Factory(t) {\n    return new (t || AuthInterceptor)(i0.ɵɵinject(i1.TokenStorageService), i0.ɵɵinject(i2.AuthService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthInterceptor,\n    factory: AuthInterceptor.ɵfac\n  });\n}\nexport const authInterceptorProviders = [{\n  provide: HTTP_INTERCEPTORS,\n  useClass: AuthInterceptor,\n  multi: true\n}];","map":{"version":3,"names":["HTTP_INTERCEPTORS","BehaviorSubject","TOKEN_HEADER_KEY","AuthInterceptor","constructor","tokenService","authService","isRefreshing","refreshTokenSubject","addTokenHeader","request","token","clone","headers","set","_","i0","ɵɵinject","i1","TokenStorageService","i2","AuthService","_2","factory","ɵfac","authInterceptorProviders","provide","useClass","multi"],"sources":["/home/mkuczyns/desktop/MGR/orleans-frontend/src/app/_helpers/auth.interceptor.ts"],"sourcesContent":["import { HTTP_INTERCEPTORS, HttpEvent, HttpErrorResponse } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\n\nimport { TokenStorageService } from '../_services/token-storage.service';\nimport { AuthService } from '../_services/auth.service';\n\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { catchError, filter, switchMap, take } from 'rxjs/operators';\n\nconst TOKEN_HEADER_KEY = 'Authorization';\n\n@Injectable()\n// export class AuthInterceptor implements HttpInterceptor {\nexport class AuthInterceptor {\n  private isRefreshing = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(private tokenService: TokenStorageService, private authService: AuthService) { }\n\n//   intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<Object>> {\n//     let authReq = req;\n//     const token = this.tokenService.getToken();\n//     if (token != null) {\n//       authReq = this.addTokenHeader(req, token);\n//     }\n\n//     return next.handle(authReq).pipe(catchError(error => {\n//       if (error instanceof HttpErrorResponse && !authReq.url.includes('auth/signin') && error.status === 401) {\n//         return this.handle401Error(authReq, next);\n//       }\n\n//       return throwError(error);\n//     }));\n//   }\n\n//   private handle401Error(request: HttpRequest<any>, next: HttpHandler) {\n//     if (!this.isRefreshing) {\n//       this.isRefreshing = true;\n//       this.refreshTokenSubject.next(null);\n\n//       const token = this.tokenService.getRefreshToken();\n\n//       if (token)\n//         return this.authService.refreshToken(token).pipe(\n//           switchMap((token: any) => {\n//             this.isRefreshing = false;\n\n//             this.tokenService.saveToken(token.accessToken);\n//             this.refreshTokenSubject.next(token.accessToken);\n            \n//             return next.handle(this.addTokenHeader(request, token.accessToken));\n//           }),\n//           catchError((err) => {\n//             this.isRefreshing = false;\n            \n//             this.tokenService.signOut();\n//             return throwError(err);\n//           })\n//         );\n//     }\n\n//     return this.refreshTokenSubject.pipe(\n//       filter(token => token !== null),\n//       take(1),\n//       switchMap((token) => next.handle(this.addTokenHeader(request, token)))\n//     );\n//   }\n\n  private addTokenHeader(request: HttpRequest<any>, token: string) {\n    return request.clone({ headers: request.headers.set(TOKEN_HEADER_KEY, 'Bearer ' + token) });\n  }\n}\n\nexport const authInterceptorProviders = [\n  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }\n];"],"mappings":"AAAA,SAASA,iBAAiB,QAAsC,sBAAsB;AAOtF,SAASC,eAAe,QAAgC,MAAM;;;;AAG9D,MAAMC,gBAAgB,GAAG,eAAe;AAGxC;AACA,OAAM,MAAOC,eAAe;EAI1BC,YAAoBC,YAAiC,EAAUC,WAAwB;IAAnE,KAAAD,YAAY,GAAZA,YAAY;IAA+B,KAAAC,WAAW,GAAXA,WAAW;IAHlE,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,mBAAmB,GAAyB,IAAIP,eAAe,CAAM,IAAI,CAAC;EAES;EAE7F;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EAEA;EACA;EACA;EAEA;EACA;EACA;EACA;EAEA;EAEA;EACA;EACA;EACA;EAEA;EACA;EAEA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EAEUQ,cAAcA,CAACC,OAAyB,EAAEC,KAAa;IAC7D,OAAOD,OAAO,CAACE,KAAK,CAAC;MAAEC,OAAO,EAAEH,OAAO,CAACG,OAAO,CAACC,GAAG,CAACZ,gBAAgB,EAAE,SAAS,GAAGS,KAAK;IAAC,CAAE,CAAC;EAC7F;EAAC,QAAAI,CAAA,G;qBAzDUZ,eAAe,EAAAa,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,mBAAA,GAAAH,EAAA,CAAAC,QAAA,CAAAG,EAAA,CAAAC,WAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAfnB,eAAe;IAAAoB,OAAA,EAAfpB,eAAe,CAAAqB;EAAA;;AA4D5B,OAAO,MAAMC,wBAAwB,GAAG,CACtC;EAAEC,OAAO,EAAE1B,iBAAiB;EAAE2B,QAAQ,EAAExB,eAAe;EAAEyB,KAAK,EAAE;AAAI,CAAE,CACvE"},"metadata":{},"sourceType":"module","externalDependencies":[]}